# 29.03.2024

# ОС/Лекция 6

# Управление памятью

Абстракция памяти нужна, чтобы у программистов была возможность писать программы так, как будто бы они не зависят от количества оперативной памяти, установленной в компьютере.

## Организация памяти

![[suai_os_program_memory_layout.png]]

## Почему нельзя адресовать физическую память напрямую?

Пусть у нас есть две программы. Каждая программа занимает 16КБ; объём оперативной памяти - 32КБ. Обе программы как будто бы успешно можно загрузить в оперативную память. Если при выполнении второй программы нужно будет переместиться в часть памяти, которая занята другой программой, то это нарушит доступ к памяти. Проблема состоит в том, что <u>перед каждым запуском</u> программы нужно будет вручную править все адреса так, чтобы они соответствовали действительности. Эта ситуация подводит нас к следующему понятию.

## Адресное пространство

Адресное пространство - набор адресов, который может быть использован процессом для обращения к памяти. Каждый процесс имеет своё независимое АП. Адрес 0x2A в одном процессе соответсвует иному физическому месту, чем адрес 0x2A в другом процессе.

В качестве примера адресных пространств из жизни можно привести:
- телефонные номера;
- порты ввода-вывода CPU;

### Базовый и ограничительный регистры

Данный подход требует аппаратной поддержки, так как необходимо, чтобы каждое обращение к памяти было очень дешёвым с точки зрения производительности.

Эта концепция подразумевает, что в процессоре будут два доп. регистра: базовый и ограничительный. При изменении контекста меняется значение в базовом регистре.

Алгритм:
при безусловном переходе (JMP)
- берётся значение базового регистра
- к нему прибавляется значение из JMP (адрес перехода).

Ограничительный регистр нужен для того, чтобы произвести проверку, которая состоит в том, что выражение "адрес + базовый регистр" меньше границы памяти процесса.

Недостатки:
- этот подход предполагает, что процесс будет занимать непрерывную область памяти (не должно быть фрагмнетированных областей памяти);

## Проблема нехватки места в ОЗУ

Основными подходами решения данной проблемы является:
- своппинг;
- виртуальная память.

### Своппинг

Суть в том, что при нехватке памяти для процесса, мы выгружаем одну из областей оперативной памяти на жёсткий диск. Таким образом, освобождается место в оперативной памяти для новых процессов и данных.

Когда выгруженный на жёсткий диск процесс снова потребуется, мы свопим какой-то другой ненужный процесс, а в освободившееся место выгружаем процесс A.

Недостаток данного подхода состоит в том, что выгружаем процессы цельными кусками. Если процесс достаточно большой, то на его выгрузке на жёсткий диск потребуется много времени.

Для работы алгоритма своппинга нужно следить за свободной памятью (с точки зрения алгоритма). Для отслеживания свободной памяти используются два основных подхода:
- битовые матрицы;
- связаные списки.

В битовой матрицы незанятые ячейки памяти отмечаются последовательностью нулей, а занятые последовательностью единиц.

В случае связных исписков, в каждом элементе храняться три поля:
- свободен/занят фрагмент;
- адрес начала сегмента;
- длина сегмента.

Связный список целиком создаёт так называему карту, по которой можно находить занятые и незанятые сегменты определённой длины.

Битовые матрицы не показывают границы процессов. Связный список таким недостатком не обладает: в его случае всегда понятные границы сегментов.

Своппинг далеко не самая удобная "штука" в случае процессов большого размера.

### Виртуальная память

Базовый и ограничительный регистры, своппинг в соврменных операционных системах не используются. Вместо них применяется подход, который называется Виртуальная память.

Виртуальное адресное пространство означает, что у нас есть только виртуальный адрес. Процессы будут обращаться именно по виртуальным адресам. Виртуальное адресное пространство начинается с 0 адреса и ограничивается разрядностью ОС по формуле: верхний адрес == 2^<разряднсть ос>

Необходимо как-то сопоставить виртуальное адресное пространство физической памяти. Разобьём всё виртуальное адресное пространство на равные "кусочки" - виртуальные страницы. Физическая память в подавляющем большинстве случаев <u>меньше</u>, размера виртуальной памяти. Физическую память также разметим на равные кусочки такого же размера, как и в виртуальной памяти. Теперь заведём таблицу, для того, чтобы сопоставить виртуальные адреса физическим. Сопоставлять будем "кусочками". Заводим специальную таблицу - таблицу страниц - и говорим, что, например, виртуальной страницу с номером 0 соответсвует страничный блок 2 (физическая страница с индексом 2). При каждом обращении к памяти, мы заглядываем в таблицу страниц и совершаем преобразование из виртуальных адресов в физические. Физический адрес приложение не знает, оно знает только виртуальный адрес. Физическая страница == страничный блок. Внутри страниц адрессация абсолютная. Т.е. 10-й байт в виртуальной странице соответсвует 10-му байту в соотвествующем страничном блоке.

### Как в данном подходе решается проблема запуска нескольких процессов?

если несколько процессов запущены, то у каждого будет своя таблица виртуальных страниц, которая будет некоторым образом мапиться на страничные блоки физической памяти.

## Поддержка виртуальной памяти в современных компьютерах 

Поддержка виртуальной памяти осуществляется с помощью Диспетчера памяти или Memory Management Unit (MMU).

Диспетчера памяти - аппаратное устройство. Внутри него находится таблица страниц. При каждом переключении контекста операционная система должна перепрошить MMU на таблицу страниц нового процесса.

Алгоритм работы MMU:
- на вход поступает какой-то виртуальный адрес;
- виртуальный адрес разбивается на две части:
	- первая часть (нижние биты): размер смещения (кратен виртуальной странице). номер байта внутри виртуальной страници;
	- вторая часть (верхние биты): номер виртуальной страницы.
- обращаемся к таблице виртуальных страниц;
- по ней определяем номер страничного блока;
- 0 или 1 справа от номера страничного блока. 0 - память ещё не проинициализированна или память выгружена на жёсткий диск. 1 - память занята. Это так называемые биты присутсвия/отсуствия.

![[suai_os_mmu_algorithm.jpg]]

## Быстрое преобразование адреса

Буфер быстрого преобразования адреса (Translation Look-aside Buffer, TLB) - устройство на основе ассоциативной памяти внутри диспетчера памяти (MMU). Это устройство представляет собой аппаратно реализованную хеш-таблицу, которая обеспечивает поиск за O(1). Также она выступает кешем, благодаря которому все последующие обращения к некоторой странице будут идти сразу через TLB.

Колонка "Изменена в таблице". Бит изменения устанавливается в 1 каждый раз, когда происходит запись.

![[suai_os_fast_address_conversion.jpg]]

## Таблицы страниц для больших объёмов памяти

Из того, что процессов очень много, а размер таблицы страниц очень большой, то мы можем всю оператвную память занять только таблицей страниц и ничем полезным.

Для того, чтобы такого не произошло используется подход называемый многоуровневые таблицы страниц. Изменяется структура виртуального адреса. в ней теперь адресуется не одна страница и смещение, а несколько адресов в иерархии страниц и конечное смещение. Вводится понятие двухуровневой таблицы страниц. Первый уровень адресует таблицы нижнего уровня.

\[адрес в таблице первого уровня\] -> \[адрес в таблице второго уровня\] -> смещение в странице, на которую мы попали из таблицы второго уровня.

В Линукс на данный момент используется трёхуровневая таблица страниц.